"""
Module defining the random sampler object.
"""

import logging
import random
import os
import sys
from contextlib import suppress

from scisample.base_sampler import BaseSampler
from scisample.utils import log_and_raise_exception
from scisample.utils import test_for_uniform_lengths, test_for_min_max

# @TODO: can this duplicate code be removed?
UQPIPELINE_SAMPLE = False
UQPIPELINE_SAMPLE_PATH = '/collab/usr/gapps/uq/UQPipeline/smplg_cmpnt'
if os.path.exists(UQPIPELINE_SAMPLE_PATH):
    sys.path.append(UQPIPELINE_SAMPLE_PATH)
    with suppress(ModuleNotFoundError):
        import sampling.sampler as sampler
        UQPIPELINE_SAMPLE = True

LOG = logging.getLogger(__name__)

class UQPipelineSampler(BaseSampler):
    """
    Class which wraps UQPipeline sampling methods.

    .. code:: yaml

        sampler:
            type: uqpipeline
            uq_type: <UQPipeline Sampler keyword>
                     cartesian_cross, centered, corners, default_value, geolhs,
                     list, montecarlo, moat, multi_normal, pdf, quasi_rn,
                     rawsamplepoints, samplepoints, stdlhs, uniform
                     <Also accepts class names>
                     LatinHyperCubeSampler, CartesianCrossSampler
            num_samples: 5      # uq_type accepts either
            num_points: 5       # uq_type accepts either
            <uqpipeline parameters>
            constants:
                X1: 20
            parameters:         # uq_type box and range are entered here
                X2:             # some uq_types accept range or list
                    min: 5
                    max: 10
                X3: [5, 10]     # some uq_types accept range or list

    A total of ``num_samples`` will be generated. Entries in the ``constants``
    dictionary will be added to all samples. Entries in the ``parameters``
    block will be selected from a range of ``min`` to ``max``.  The result of
    the above block would something like:

    .. code:: python

        [{X1: 20, X2: 5.632222227306036, X3: 6.633392173916806},
         {X1: 20, X2: 7.44369755967992, X3: 8.941266067294213}]
    """
    # We choose to be explicit here so we don't
    # have to worry about eval. This could be loosened later.
    uqpipeline_sample_dict = {
        "LatinHyperCubeSampler": sampler.LatinHyperCubeSampler,
        "lhs": sampler.LatinHyperCubeSampler,
        "stdlhs": sampler.LatinHyperCubeSampler,
        "geolhs": sampler.LatinHyperCubeSampler,
        }
    def __init__(self, data):
        """
        Initialize the sampler.

        :param data: Dictionary of sampler data.
        """
        super().__init__(data)
        self.check_validity()

    def check_validity(self):
        super().check_validity()
        self._check_variables()

        # self._check_variables_existence()
        # self._check_variables_for_dups()

        if not 'uq_type' in self.data:
            log_and_raise_exception(
                "'uq_type' is required for a uqpipeline sampler.")

        if not self.data['uq_type'] in self.uqpipeline_sample_dict:
            log_and_raise_exception(
                f"'uq_type' ('{self.data['uq_type']}') is not supported by scisample.")

        if (self.uqpipeline_sample_dict[self.data['uq_type']]
            == sampler.LatinHyperCubeSampler):
            # @TODO: test four combos of num_points/num_samples
            if ('num_points' in self.data 
                and 'num_samples' in self.data):
                log_and_raise_exception(
                    "Error uqpipeline samplers require "
                    "only one of 'num_points' and 'num_samples'.\n"
                    f"num_points: {self.data['num_points']}\n"
                    f"num_samples: {self.data['num_samples']}")
            if not ('num_points' in self.data 
                    or 'num_samples' in self.data):
                log_and_raise_exception(
                    f"Error uqpipeline samplers ('{self.data['uq_type']}') require "
                    "at least one of 'num_points' and 'num_samples'.\n")

            if 'num_points' in self.data:
                self.data['num_samples'] = self.data['num_points']
        
        # @TODO: add support for discrete variables
        # @TODO: add support for default
        test_for_min_max(self.data["parameters"])

        with suppress(KeyError):
            test_for_uniform_lengths(self.data['parameters'].items())

    @property
    def parameters(self):
        """
        Return a of list of the parameters being generated by the
        sampler.
        """
        return self._parameters_constants_parameters_only()

    def get_samples(self):
        """
        Get samples from the sampler.

        This returns samples as a list of dictionaries, with the
        sample variables as the keys:

        .. code:: python

            [{'b': 0.89856, 'a': 1}, {'b': 0.923223, 'a': 1}, ... ]
        """
        if self._samples is not None:
            return self._samples

        self._samples = []

        num_samples = 1

        parameters = {'X2': [1, 2], 'X3': [1, 2]}
        with suppress(KeyError):
            for key, value in parameters.items():
                num_samples = len(value)
                break

        for i in range(num_samples):
            new_sample = {}

            with suppress(KeyError):
                new_sample.update(self.data['constants'])

            with suppress(KeyError):
                for key, value in parameters.items():
                    new_sample[key] = value[i]

            self._samples.append(new_sample)

        return self._samples

